From 5a992523bc24d39590465cc9bf00bfdb7b2f1b44 Mon Sep 17 00:00:00 2001
From: chentau <tchen1998@gmail.com>
Date: Sat, 30 Jan 2021 19:46:12 -0800
Subject: [PATCH 01/12] Allow for filtering insert completion matches using a
 lua function

---
 src/nvim/api/vim.c | 112 ++++++++++++++
 src/nvim/edit.c    | 367 ++++++++++++++++++++++++++++++++-------------
 2 files changed, 372 insertions(+), 107 deletions(-)

diff --git a/src/nvim/api/vim.c b/src/nvim/api/vim.c
index 09895a211..1a060b18a 100644
--- a/src/nvim/api/vim.c
+++ b/src/nvim/api/vim.c
@@ -50,6 +50,7 @@
 #include "nvim/viml/parser/expressions.h"
 #include "nvim/viml/parser/parser.h"
 #include "nvim/ui.h"
+#include "nvim/undo.h"
 
 #define LINE_BUFFER_SIZE 4096
 
@@ -2851,3 +2852,114 @@ void nvim_set_decoration_provider(Integer ns_id, DictionaryOf(LuaRef) opts,
 error:
   clear_provider(p);
 }
+
+///
+/// Set matches and start insert completion: see |complete()|.
+///
+/// @param startcol: Byte offset where the completed text starts.
+///                     Any text between startcol and the current
+///                     cursor col is replaced by the completion.
+/// @param matches: A list of string matches.
+/// @param opts: Dictionary. No possible keys for now
+//
+// todo: completefunc with refresh: always
+// todo: figure out what to do with ctrl_e and ctrl_l
+// todo: what to do if filterfunc != NULL AND completion entry
+// has icase/equal set.
+String nvim_complete(Integer startcol,
+                   Object matches,
+                   DictionaryOf(LuaRef) opts,
+                   Error *err)
+  FUNC_API_SINCE(7)
+{
+  typval_T tv;
+  extern LuaRef *user_filterfunc;
+  extern LuaRef *active_filterfunc;
+  LuaRef filterfunc;
+
+  if (matches.type != kObjectTypeArray) {
+    api_set_error(err, kErrorTypeValidation,
+              "wrong type");
+  }
+
+  if ((State & INSERT) == 0) {
+    api_set_error(err, kErrorTypeValidation,
+            "complete() can only be used in Insert mode");
+    goto error;
+  }
+
+  // Check for undo allowed here, because if something was already inserted
+  // the line was already saved for undo and this check isn't done.
+  if (!undo_allowed())
+      goto error;
+
+  if (startcol <= 0) {
+      goto error;
+  }
+
+  for (size_t i = 0; i < opts.size; i++) {
+    String k = opts.items[i].key;
+    Object *v = &opts.items[i].value;
+
+    if (strequal(k.data, "filterfunc")){
+      if (v->type != kObjectTypeLuaRef) {
+        api_set_error(err, kErrorTypeValidation,
+                "expected lua function");
+        goto error;
+      }
+      filterfunc = api_new_luaref(v->data.luaref);
+      user_filterfunc = xmalloc(sizeof(LuaRef));
+      memcpy(user_filterfunc, &filterfunc, sizeof(LuaRef));
+      active_filterfunc = user_filterfunc;
+    } else {
+      api_set_error(err, kErrorTypeValidation,
+              "undexpected key");
+      goto error;
+    }
+  }
+
+  object_to_vim(matches, &tv, err);
+  if ERROR_SET(err){
+      goto error;
+  }
+
+  set_completion((colnr_T)startcol - 1, tv.vval.v_list);
+
+error:
+  tv_clear(&tv);
+
+  String ret = STRING_INIT;
+  return ret;
+}
+
+///
+/// Register a lua function for filtering completion matches.
+/// The function must take in two arguments: the prefix (the
+/// currently typed text), and the text for a completion entry, and 
+/// returns a float. Higher return values imply a better match, and a
+/// return value of 0 removes the entry from being shown.
+/// To remove the currently registered function, call the function
+/// with a nil value.
+///
+/// @param func: function to register for filtering.
+///
+void nvim_register_filterfunc(LuaRef func, Error *err)
+FUNC_API_SINCE(7)
+{
+  extern LuaRef *global_filterfunc;
+  extern LuaRef *active_filterfunc;
+  LuaRef filterfunc;
+
+  if (global_filterfunc != NULL) {
+    XFREE_CLEAR(global_filterfunc);
+  }
+
+  if (func == -1) { // Nil
+    return;
+  }
+
+  filterfunc = api_new_luaref(func);
+  global_filterfunc = xmalloc(sizeof(LuaRef));
+  memcpy(global_filterfunc, &filterfunc, sizeof(LuaRef));
+  active_filterfunc = global_filterfunc;
+}
diff --git a/src/nvim/edit.c b/src/nvim/edit.c
index b2abb0607..4dc6f0ad5 100644
--- a/src/nvim/edit.c
+++ b/src/nvim/edit.c
@@ -10,6 +10,8 @@
 #include <inttypes.h>
 #include <stdbool.h>
 
+#include <lua.h>
+
 #include "nvim/vim.h"
 #include "nvim/ascii.h"
 #include "nvim/edit.h"
@@ -59,6 +61,8 @@
 #include "nvim/mark.h"
 #include "nvim/os/input.h"
 #include "nvim/os/time.h"
+#include "nvim/api/private/helpers.h"
+#include "nvim/lua/executor.h"
 
 // Definitions used for CTRL-X submode.
 // Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[]
@@ -150,6 +154,22 @@ struct compl_S {
   int cp_number;                // sequence number
 };
 
+// Structure that stores the score of each completion entry
+// Used to sort the pum items.
+typedef struct compl_score_S compl_score_T;
+struct compl_score_S {
+  compl_T   *compl;
+  double score;
+};
+
+// lua functions used to filter completion matches
+// global_filterfunc is used for all completion sources,
+// while user_filterfunc is only used to filter matches
+// from vim.api.nvim_complete().
+LuaRef *global_filterfunc = NULL;
+LuaRef *user_filterfunc = NULL;
+LuaRef *active_filterfunc = NULL;
+
 /*
  * All the current matches are stored in a list.
  * "compl_first_match" points to the start of the list.
@@ -2434,12 +2454,43 @@ static int ins_compl_add(char_u *const str, int len,
 /// @param  match  completion match
 /// @param  str    character string to check
 /// @param  len    lenth of "str"
-static bool ins_compl_equal(compl_T *match, char_u *str, size_t len)
+///
+/// Returns the matching score: 0 means no match, any other value
+/// implies a match, with higher scores indicating more matching.
+static double ins_compl_match(compl_T *match, char_u *str, size_t len)
   FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL
 {
+  ArrayOf(String) args = ARRAY_DICT_INIT;
+  Object retval;
+  Error err = ERROR_INIT;
+
   if (match->cp_flags & CP_EQUAL) {
     return true;
   }
+
+  if (active_filterfunc != NULL) {
+    ADD(args, STRING_OBJ(cstr_to_string((char *)str)));
+    ADD(args, STRING_OBJ(cstr_to_string((char *)match->cp_str)));
+
+    retval = nlua_call_ref(*active_filterfunc, NULL, args, true, &err);
+
+    api_free_array(args);
+
+    if (ERROR_SET(&err)) {
+      EMSG(_(err.msg));
+      return 0;
+    } else {
+      if (retval.type == kObjectTypeFloat) {
+        return retval.data.floating;
+      } else if (retval.type == kObjectTypeInteger) {
+        return retval.data.integer;
+      } else {
+        EMSG(_("invalid return type from function"));
+        return 0;
+      }
+    }
+  }
+
   if (match->cp_flags & CP_ICASE) {
     return STRNICMP(match->cp_str, str, len) == 0;
   }
@@ -2699,120 +2750,205 @@ static void trigger_complete_changed_event(int cur)
   tv_dict_clear(v_event);
 }
 
-/// Show the popup menu for the list of matches.
+// comparator function for use in qsort.
+static int compare_scores(const void* a, const void *b) {
+  double val = ((compl_score_T *)b)->score - ((compl_score_T *)a)->score;
+  if (val < 0) {
+    return -1;
+  } else if (val > 0) {
+      return 1;
+  } else {
+    return 0;
+  }
+}
+
+// sort the linked list of completion items based on the scores
+// in the scores array.
+static void sort_completions(int num_items, compl_score_T *scores)
+{
+  int i;
+  const bool cyclic = compl_first_match->cp_prev != NULL;
+  compl_T *first;
+  compl_T *last;
+  compl_T *prev;
+  compl_T *cur;
+
+  qsort(scores, num_items, sizeof(compl_score_T), compare_scores);
+
+  // TODO(chentau): We don;t need to sort the entire linked
+  // list; we just need to sort the first compl_match_arraysize entries,
+  // since only those will be shown in the pum.
+  for (i = 1; i < num_items; ++i) {
+    prev = scores[i - 1].compl;
+    cur = scores[i].compl;
+    prev->cp_next = cur;
+    cur->cp_prev = prev;
+  }
+
+  first = scores[0].compl;
+  last = scores[num_items - 1].compl;
+  first->cp_prev = cyclic ? last : NULL;
+  last->cp_next = cyclic ? first : NULL;
+
+  compl_first_match = first;
+}
+
+///
+/// Sets compl_match_array by filtering the currently available completion items.
 /// Also adjusts "compl_shown_match" to an entry that is actually displayed.
-void ins_compl_show_pum(void)
+/// Returns the index of the currently shown completion item in the array,
+/// or -1 if no completion entry is selected.
+///
+int set_compl_match_array(void)
 {
   compl_T     *compl;
   compl_T     *shown_compl = NULL;
+  compl_score_T *scores;
   bool did_find_shown_match = false;
   bool shown_match_ok = false;
-  int i;
+  int lead_len;
+  int i = 0;
   int cur = -1;
-  colnr_T col;
-  int lead_len = 0;
-  bool array_changed = false;
 
-  if (!pum_wanted() || !pum_enough_matches())
-    return;
+  compl_match_arraysize = 0;
+  compl = compl_first_match;
+  //
+  // If it's user complete function and refresh_always,
+  // do not use "compl_leader" as prefix filter.
+  //
+  if (ins_compl_need_restart()) {
+    XFREE_CLEAR(compl_leader);
+  }
+  if (compl_leader != NULL) {
+    lead_len = (int)STRLEN(compl_leader);
+  }
 
-  // Dirty hard-coded hack: remove any matchparen highlighting.
-  do_cmdline_cmd("if exists('g:loaded_matchparen')|3match none|endif");
+  scores = xcalloc(compl_matches + 1, sizeof(compl_score_T));
 
-  // Update the screen before drawing the popup menu over it.
-  update_screen(0);
+  do {
+    scores[i].compl = compl;
+    if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0) {
+      scores[i].score = 1;
+      if (compl_leader != NULL) {
+        scores[i].score = ins_compl_match(compl, compl_leader, lead_len);
+      }
 
-  if (compl_match_array == NULL) {
-    array_changed = true;
-    // Need to build the popup menu list.
-    compl_match_arraysize = 0;
-    compl = compl_first_match;
-    //
-    // If it's user complete function and refresh_always,
-    // do not use "compl_leader" as prefix filter.
-    //
-    if (ins_compl_need_restart()) {
-      XFREE_CLEAR(compl_leader);
-    }
-    if (compl_leader != NULL) {
-      lead_len = (int)STRLEN(compl_leader);
-    }
-    do {
-      if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0
-          && (compl_leader == NULL
-              || ins_compl_equal(compl, compl_leader, lead_len))) {
+      if (scores[i].score) {
         compl_match_arraysize++;
       }
-      compl = compl->cp_next;
-    } while (compl != NULL && compl != compl_first_match);
-    if (compl_match_arraysize == 0)
-      return;
-
-    assert(compl_match_arraysize >= 0);
-    compl_match_array = xcalloc(compl_match_arraysize, sizeof(pumitem_T));
-    /* If the current match is the original text don't find the first
-     * match after it, don't highlight anything. */
-    if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) {
-      shown_match_ok = true;
+    } else {
+      // We don't show the original match, but we still assign
+      // a score so that it doesn't get lost during sort_completion().
+      scores[i].score = -1;
     }
+    i++;
+    compl = compl->cp_next;
+  } while (compl != NULL && compl != compl_first_match);
 
-    i = 0;
-    compl = compl_first_match;
-    do {
-      if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0
-          && (compl_leader == NULL
-              || ins_compl_equal(compl, compl_leader, lead_len))) {
-        if (!shown_match_ok) {
-          if (compl == compl_shown_match || did_find_shown_match) {
-            /* This item is the shown match or this is the
-             * first displayed item after the shown match. */
-            compl_shown_match = compl;
-            did_find_shown_match = true;
-            shown_match_ok = true;
-          } else {
-            // Remember this displayed match for when the
-            // shown match is just below it.
-            shown_compl = compl;
-          }
-          cur = i;
-        }
+  if (compl_match_arraysize == 0) {
+    xfree(scores);
+    return -1;
+  }
 
-        if (compl->cp_text[CPT_ABBR] != NULL)
-          compl_match_array[i].pum_text =
-            compl->cp_text[CPT_ABBR];
-        else
-          compl_match_array[i].pum_text = compl->cp_str;
-        compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];
-        compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];
-        if (compl->cp_text[CPT_MENU] != NULL)
-          compl_match_array[i++].pum_extra =
-            compl->cp_text[CPT_MENU];
-        else
-          compl_match_array[i++].pum_extra = compl->cp_fname;
-      }
+  assert(compl_match_arraysize > 0);
+  compl_match_array = xcalloc(compl_match_arraysize, sizeof(pumitem_T));
 
-      if (compl == compl_shown_match) {
-        did_find_shown_match = true;
+  // If we are doing filtering via a lua function, sort the completion
+  // items according to the scores
+  if (active_filterfunc != NULL && compl_leader != NULL) {
+    sort_completions(compl_matches + 1, scores);
+  }
 
-        /* When the original text is the shown match don't set
-         * compl_shown_match. */
-        if (compl->cp_flags & CP_ORIGINAL_TEXT) {
-          shown_match_ok = true;
-        }
+  // If the current match is the original text don't find the first
+  // match after it, don't highlight anything.
+  if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) {
+    shown_match_ok = true;
+  }
 
-        if (!shown_match_ok && shown_compl != NULL) {
-          /* The shown match isn't displayed, set it to the
-           * previously displayed match. */
-          compl_shown_match = shown_compl;
+  i = 0;
+  compl = compl_first_match;
+  do {
+    if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0
+        && (scores[i].score)) {
+      if (!shown_match_ok) {
+        if (compl == compl_shown_match || did_find_shown_match) {
+          // This item is the shown match or this is the
+          // first displayed item after the shown match.
+          compl_shown_match = compl;
+          did_find_shown_match = true;
           shown_match_ok = true;
+        } else {
+          // Remember this displayed match for when the
+          // shown match is just below it.
+          shown_compl = compl;
         }
+        cur = i;
       }
-      compl = compl->cp_next;
-    } while (compl != NULL && compl != compl_first_match);
 
-    if (!shown_match_ok) {        // no displayed match at all
-      cur = -1;
+      if (compl->cp_text[CPT_ABBR] != NULL) {
+        compl_match_array[i].pum_text =
+          compl->cp_text[CPT_ABBR];
+      } else {
+        compl_match_array[i].pum_text = compl->cp_str;
+      }
+
+      compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];
+      compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];
+
+      if (compl->cp_text[CPT_MENU] != NULL) {
+        compl_match_array[i++].pum_extra =
+          compl->cp_text[CPT_MENU];
+      } else {
+        compl_match_array[i++].pum_extra = compl->cp_fname;
+      }
     }
+
+    if (compl == compl_shown_match) {
+      did_find_shown_match = true;
+
+      // When the original text is the shown match don't set
+      // compl_shown_match.
+      if (compl->cp_flags & CP_ORIGINAL_TEXT) {
+        shown_match_ok = true;
+      }
+
+      if (!shown_match_ok && shown_compl != NULL) {
+        // The shown match isn't displayed, set it to the
+        // previously valid displayed match.
+        compl_shown_match = shown_compl;
+        shown_match_ok = true;
+      }
+    }
+    compl = compl->cp_next;
+  } while (compl != NULL && compl != compl_first_match);
+  if (!shown_match_ok) { // no displayed match at all
+    cur = -1;
+  }
+
+  xfree(scores);
+  return cur;
+}
+
+/// Show the popup menu for the list of matches.
+void ins_compl_show_pum(void)
+{
+  int cur;
+  int i;
+  colnr_T col;
+  bool array_changed = false;
+
+  if (!pum_wanted() || !pum_enough_matches())
+    return;
+
+  // Dirty hard-coded hack: remove any matchparen highlighting.
+  do_cmdline_cmd("if exists('g:loaded_matchparen')|3match none|endif");
+
+  // Update the screen before drawing the popup menu over it.
+  update_screen(0);
+
+  if (compl_match_array == NULL) {
+    array_changed = true;
+    cur = set_compl_match_array();
   } else {
     // popup menu already exists, only need to find the current item.
     for (i = 0; i < compl_match_arraysize; i++) {
@@ -2825,6 +2961,10 @@ void ins_compl_show_pum(void)
     }
   }
 
+  if (compl_match_arraysize == 0) {
+    return;
+  }
+
   // In Replace mode when a $ is displayed at the end of the line only
   // part of the screen would be updated.  We do need to redraw here.
   dollar_vcol = -1;
@@ -3102,22 +3242,25 @@ static void ins_compl_free(void)
   do {
     match = compl_curr_match;
     compl_curr_match = compl_curr_match->cp_next;
-    xfree(match->cp_str);
-    // several entries may use the same fname, free it just once.
-    if (match->cp_flags & CP_FREE_FNAME) {
-      xfree(match->cp_fname);
-    }
-    for (int i = 0; i < CPT_COUNT; i++) {
-      xfree(match->cp_text[i]);
-    }
-    tv_clear(&match->cp_user_data);
-    xfree(match);
+    ins_compl_free_item(match);
   } while (compl_curr_match != NULL && compl_curr_match != compl_first_match);
   compl_first_match = compl_curr_match = NULL;
   compl_shown_match = NULL;
   compl_old_match = NULL;
 }
 
+static void ins_compl_free_item(compl_T *compl) {
+  if (compl->cp_flags & CP_FREE_FNAME) {
+    xfree(compl->cp_fname);
+  }
+  for (int i = 0; i < CPT_COUNT; i++) {
+    xfree(compl->cp_text[i]);
+  }
+  xfree(compl->cp_str);
+  tv_clear(&compl->cp_user_data);
+  xfree(compl);
+}
+
 static void ins_compl_clear(void)
 {
   compl_cont_status = 0;
@@ -3311,7 +3454,7 @@ static int ins_compl_bs(void)
   // Respect the 'backspace' option.
   if ((int)(p - line) - (int)compl_col < 0
       || ((int)(p - line) - (int)compl_col == 0
-          && ctrl_x_mode != CTRL_X_OMNI) || ctrl_x_mode == CTRL_X_EVAL
+          && (ctrl_x_mode != CTRL_X_OMNI && ctrl_x_mode != CTRL_X_EVAL))
       || (!can_bs(BS_START) && (int)(p - line) - (int)compl_col
           - compl_length < 0)) {
     return K_BS;
@@ -3483,7 +3626,7 @@ static void ins_compl_addfrommatch(void)
       for (cp = compl_shown_match->cp_next; cp != NULL
            && cp != compl_first_match; cp = cp->cp_next) {
         if (compl_leader == NULL
-            || ins_compl_equal(cp, compl_leader,
+            || ins_compl_match(cp, compl_leader,
                 (int)STRLEN(compl_leader))) {
           p = cp->cp_str;
           break;
@@ -3727,6 +3870,14 @@ static bool ins_compl_prep(int c)
       ins_compl_free();
       compl_started = false;
       compl_matches = 0;
+
+      // When we are done completing from vim.api.nvim_complete(),
+      // reset the user filterfunc, if one was provided
+      if (user_filterfunc != NULL) {
+        XFREE_CLEAR(user_filterfunc);
+        active_filterfunc = global_filterfunc;
+      }
+
       if (!shortmess(SHM_COMPLETIONMENU)) {
         msg_clr_cmdline();                // necessary for "noshowmode"
       }
@@ -4563,7 +4714,7 @@ ins_compl_next (
       && (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0) {
     // Set "compl_shown_match" to the actually shown match, it may differ
     // when "compl_leader" is used to omit some of the matches.
-    while (!ins_compl_equal(compl_shown_match,
+    while (!ins_compl_match(compl_shown_match,
                             compl_leader, STRLEN(compl_leader))
            && compl_shown_match->cp_next != NULL
            && compl_shown_match->cp_next != compl_first_match) {
@@ -4573,11 +4724,11 @@ ins_compl_next (
     /* If we didn't find it searching forward, and compl_shows_dir is
      * backward, find the last match. */
     if (compl_shows_dir == BACKWARD
-        && !ins_compl_equal(compl_shown_match,
+        && !ins_compl_match(compl_shown_match,
             compl_leader, (int)STRLEN(compl_leader))
         && (compl_shown_match->cp_next == NULL
             || compl_shown_match->cp_next == compl_first_match)) {
-      while (!ins_compl_equal(compl_shown_match,
+      while (!ins_compl_match(compl_shown_match,
                  compl_leader, (int)STRLEN(compl_leader))
              && compl_shown_match->cp_prev != NULL
              && compl_shown_match->cp_prev != compl_first_match)
@@ -4614,6 +4765,8 @@ ins_compl_next (
       compl_shown_match = compl_shown_match->cp_prev;
       found_end |= (compl_shown_match == compl_first_match);
     } else {
+      // Reached the end of the completion list - either get more entries
+      // or simply return
       if (!allow_get_expansion) {
         if (advance) {
           if (compl_shows_dir == BACKWARD)
@@ -4651,7 +4804,7 @@ ins_compl_next (
     }
     if ((compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0
         && compl_leader != NULL
-        && !ins_compl_equal(compl_shown_match,
+        && !ins_compl_match(compl_shown_match,
                             compl_leader, STRLEN(compl_leader))) {
       todo++;
     } else {
-- 
2.30.1

